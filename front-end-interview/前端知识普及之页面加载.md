# 前端知识普及之页面加载

如果大家想继续看下面的内容的话，有一个要求，就是回答我一个问题:

**你这样写过代码吗？**

```js
window.onload = function(){
    $(".gravatar").on('click',function(){
        //...
    });
    //以及其他操作DOM的节点
}
```
如果答案是 yes. 那么，bingo, 这里我们将深入讲解，这样写代码到底有没有IQ。 

如果答案是 No. 那么，2333333, 你也可以看一下。 万一哪天用上了呢？

可能会有童鞋反问，那么，我改怎么写呢？

没错，这里就是说的就是这个。
 
使用过jquery的童鞋，应该知道有一个叫做ready的方法.

即:

```js
$(document).ready(function(){
    //操作DOM相关
    //...
})
```

那这个和上面的写法有什么区别呢？ 谁比较好一点呢(指性能)？

wait wait wait ~ 

这问题有点多诶。 不急。 想想看， jquery老大哥 就是帮你 提高性能的，肯定是下面那种好呢。
 
Why?

原因我们接着说.


## 页面加载

页面加载就是从你输入网址+enter开始，发生的一些列过程，最终到页面显示。 从微观上分的话，页面加载有两部分:

一个是以DOMContentLoaded触发为标志的DOM树的渲染完成

一个是以辅助资源img,font加载完成为触发标志的onload事件

他们两个的具体区别就是"资源的加载"这个关键点.

在获得数据响应后,页面开始解析,发生的过程为:

1. 解析HTML结构。 
2. 加载外部脚本和样式表文件。 
3. 解析并执行脚本代码。 
4. 构造HTML DOM模型。//ready执行 
5. 加载图片等外部文件。 
6. 页面加载完毕。//load执行

这只是，页面加载很浅的一块，前端能在页面加载上做的工作其实超级多。 要知道， 从你输入网站 + enter键后，发生的过程为:

重定向 => 检查DNS缓存 => DNS解析 => TCP连接 => 发请求 => 得到响应=> 浏览器处理 => 最后onload

你可以数一数，前文的页面加载和这里的页面加载的范围到底是怎样的一个区别. 也就是说上文的页面加载其实 只算是 
浏览器处理=> 最后onload这一过程。 懂吧。 很小很小。
所以，这里我们先从宏观上来讲解一下，页面加载的整个流程.

## 宏观页面加载

以前，我们来检查浏览器的时候，大部分情况下是使用

```js
console.time(specialNum);
console.timeEnd(specialNum);
```
或

```js
new Date().getTime();
//或者
Date.now();
```

上面说的两种方法， 获取的精度都是毫秒级(10^-6)，对于一些非常精确的测试，他们的作用来还是蛮有限的，而且获取数据的方式，也比较complicated.

ES5提出的performance可以获取到，微秒级别(10^-9). 而且，能够得到后台事件的更多时间数据。

他的兼容性是IE9+ 。 觉得已经足够了。

### performance.timing对象

通常，我们可以从performance.timing对象上，获得我们想要的一切时间值.具体有哪些，我就不赘述了。直接看一张图:

![performance](http://www.w3.org/TR/navigation-timing/timing-overview.png)

比如，我们获得重定向时间用:

```js
var time = performance.timing;
var redirect = time.redirectEnd - time.redirectStart; //单位为微秒
```

这就已经够我们用的啦。 
里面需要进行一点解释
即DOMContentLoaded事件 是在domContentLoaded那段触发的。图中所指的domContentLoaded其实分为两块, 一个是domContentLoadedEventStart和domContentLoadedEventEnd. 

```js
// 获取 performance 数据
var performance = {
    // memory 是非标准属性，只在 Chrome 有
    // 财富问题：我有多少内存
    memory: {
        usedJSHeapSize:  16100000, // JS 对象（包括V8引擎内部对象）占用的内存，一定小于 totalJSHeapSize
        totalJSHeapSize: 35100000, // 可使用的内存
        jsHeapSizeLimit: 793000000 // 内存大小限制
    },

    //  哲学问题：我从哪里来？
    navigation: {
        redirectCount: 0, // 如果有重定向的话，页面通过几次重定向跳转而来
        type: 0           // 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）
                          // 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面
                          // 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）
                          // 255 即 TYPE_UNDEFINED    非以上方式进入的页面
    },

    timing: {
        // 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等
        navigationStart: 1441112691935,

        // 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0
        unloadEventStart: 0,

        // 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳
        unloadEventEnd: 0,

        // 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0 
        redirectStart: 0,

        // 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0 
        redirectEnd: 0,

        // 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前
        fetchStart: 1441112692155,

        // DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
        domainLookupStart: 1441112692155,

        // DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
        domainLookupEnd: 1441112692155,

        // HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等
        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间
        connectStart: 1441112692155,

        // HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等
        // 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间
        // 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过
        connectEnd: 1441112692155,

        // HTTPS 连接开始的时间，如果不是安全连接，则值为 0
        secureConnectionStart: 0,

        // HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存
        // 连接错误重连时，这里显示的也是新建立连接的时间
        requestStart: 1441112692158,

        // HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存
        responseStart: 1441112692686,

        // HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存
        responseEnd: 1441112692687,

        // 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件
        domLoading: 1441112692690,

        // 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件
        // 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源
        domInteractive: 1441112693093,

        // DOM 解析完成后，网页内资源加载开始的时间
        // 在 DOMContentLoaded 事件抛出前发生
        domContentLoadedEventStart: 1441112693093,

        // DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）
        domContentLoadedEventEnd: 1441112693101,

        // DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件
        domComplete: 1441112693214,

        // load 事件发送给文档，也即 load 回调函数开始执行的时间
        // 注意如果没有绑定 load 事件，值为 0
        loadEventStart: 1441112693214,

        // load 事件的回调函数执行完毕的时间
        loadEventEnd: 1441112693215
    }
};
```

不过performance还有另外一个方法 now

### performance.now()

通常，我们会将该方法和Date.now()进行一个对比。

```js
performance.now();  //输出是微秒级别
Date.now();  //输出是毫秒级别
```

其中Date.now()是输出 从1970年开始的毫秒数.

performance.now()参考的是从.performance.timing.navigationStart(页面开始加载)的时间, 到现在的微秒数.

这里，我们可以使用performance.now()来模拟获取DomContentLoaded的时间。

```js
var timesnipe = performance.now();
        document.addEventListener('DOMContentLoaded', function() {
            console.log(performance.now() - timesnipe);
        }, false);

        window.addEventListener('load', function() {
           console.log(performance.now() - timesnipe);
        }, false);
//但是这样并不等同于,只能算作约等于
performance.timing.domContentLoadedEventStart - performance.timing.domLoading; //检测domLoadEvent触发时间
```

上面不相等的原因就在于，当执行script的时候，DOM其实已经开始解析DOM和页面内容， 所以会造成时间上 比 真实时间略短。另外performance还有其他几个API,比如makr,getEntries. 不过，这里因为和页面显示的关系不是很大，这里就不做过多的讲解了。